<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        /*
            一,函数
                1, 函数的定义
                    声明式
                        function 函数名称(参数--形参){
                            程序 
                            return 返回值;
                        }

                    匿名式 / 赋值式
                    
                        var 变量 = function (参数--形参){
                            程序 
                            return 返回值;
                        }

                2, 函数的调用
                    通过 函数名称() 语法形式 来调用 函数程序  

                    声明式 可以 提前调用函数 
                    赋值式 / 匿名函数 不能 提前调用函数

                3, 函数的基本介绍
                    (1), 函数的参数:
                        定义在函数 () 小括号中的 参数称为 形参,没有实际数据的
                        表示在函数中要定义一个变量,变量中存储数据,执行操作这个变量中的数据
                        要根据实际项目的需求,来设定参数
                        参数还可以设定默认值,设定默认值的参数,一定要放在所有参数最后
                        调用函数时,给 函数名称() 中定义的是 实参
                        实参就是实际赋值给形参的数据,实参给形参赋值是 一一对应赋值的
                        形参如果有实参赋值,存储的是实参数据,没有实参赋值,存储的是默认值,如果没有默认值,是undefined

                    (2), 函数的返回值
                        return 两个作用:
                            定义返回值
                            终止函数程序的执行
                                break 只能终止循环 {} 中的程序 
                                return 是终止 整个 函数 {} 中的程序 

                            必须要强调:
                                函数的执行结果返回值,必须要使用 return 定义
                                没有 return 定义的 函数,执行结果都是 undefined

                    (3), 函数的基本封装和调用原理
                        封装:
                            开辟一个内存空间,准备存储函数程序,操作系统定义一个 内存地址
                            将函数程序以 字符串形式 存储在 内存空间中
                            将 内存地址 存储在 函数名称或者变量 中

                        调用:
                            通过 函数名称或者变量 中 存储的内存地址 找到 存储空间,读取其中存储的函数程序
                            预解析 / 预解释 / 预编译
                            给 形参 赋值 实参 
                            执行函数程序
                    (4), 预解析 / 预解释 / 预编译
                        JavaScript程序执行的特点,会在JavaScript程序执行之前,预先编译解释解析一下 JavaScript所有的程序
                        找 var关键词 和 function关键词 声明定义的程序
                        var关键词定义的 变量 如果提前调用 执行结果 是 undefined , 不是 报错
                        function关键词定义的 函数 如果提前调用 可以正常执行

                    (5), 函数中变量的作用域 和 调用赋值基本原理
                        作用域:
                            局部作用域 
                                在函数内部定义的 变量 形参 只能在函数内部调用使用

                            全局作用域
                                定义在 函数 外的变量 可以在 函数内部外部都正常的调用使用

                        函数中变量的基本调用原理  就近原理
                            在函数使用一个变量  
                                自己有这个变量,调用自己的这个变量
                                自己没有,去父级程序作用域中找,如果有这个变量,使用这个变量
                                父级程序也没有这个变量,去全局作用域中找,如果有这个,使用这个变量
                                都没有,调用使用的执行结果是 undefined

                        
                        函数中变量的赋值调用原理  就近原理
                            在函数中给一个变量 执行 赋值操作
                                自己有这个变量,就赋值自己的这个变量
                                自己没有,去父级程序作用域中找,如果有这个变量,赋值这个变量
                                父级程序也没有这个变量,去全局作用域中找,如果有这个,赋值这个变量
                                都没有,赋值语句,升级为,声明语句,声明定义一个全局作用域的变量

                        只要记住一点,函数的声明一定要写 var 关键词


            二, 数组
                1, 基本概念:
                    数组是 存储数据的集合 --- 一个变量中存储多个单元,每个单元存储一个数据数值

                    数组的定义语法:
                        字面量
                        var 变量 = [数据1,数据2,....];

                        构造函数
                        var 变量 = new Array();
                        
                    数组的基本介绍
                        数组的每一个单元,都被 JavaScript 默认赋值 一个 从0开始的整数序号 --- 索引下标
                        
                        length 是 每一个数组,伪数组 天生都具有的属性
                        定义的数组的长度,也就是 单元个数
                        第一个单元的索引是0 最后一个单元的索引是 数组.length-1 
                        
                        通过 数组[索引下标] 的语法形式 可以 操作 数组的单元
                            数组[索引下标]    
                                调用指定索引下标中存储的数据数值
                            数组[索引下标] = 数据熟知   
                                如果索引下标已经存在,是 修改 数据单元 存储数据操作
                                如果索引下标不存在,是 新增 数据单元 存储数据操作
                            数组.length = 数值
                                定义数组的长度,也就是单元个数

                2, JavaScript中 操作数组的基本方法
                    见 脑图
                    数组.方法()

                3, 字符串
                    字符串称为 包装数据类型 
                    如果对字符串执行 索引下标 length 操作 
                    虽然字符串不是数组,但是也支持这两个操作方式

                    字符串的 JavaScript 操作方法 见 脑图

                4, 数组和字符串的循环遍历
                    (1) for循环
                        通过for循环 生成 0 至 最后一个单元的所有索引下标
                        通过 索引下标 操作数组的单元
                        特点: 可以通过 修改循环变量的数值 来 控制循环的执行

                    (2) for...in 循环
                        for(var 自定义变量 in 数组){ 程序 }
                        JavaScript自动将 索引下标 存储在 自定义变量中
                        特点: 不用我们自己生成 索引下标 
                              JavaScript程序会自动存储每一个单元的索引下标
                              通过 数组[自定义变量] 方式 来调用操作数组的单元
                              循环只能 逐一 , 一个一个 数组单元的循环
                              不能控制循环的执行

                    (3) forEach 循环
                        数组.forEach( function(形参1,形参2,形参3){ 程序 } )
                        JavaScript自动将 单元的数据存储在形参1中
                                         单元的索引存储在形参2中  
                                         原始数组存储在形参3中 
                        特点: 循环只能 逐一 , 一个一个 数组单元的循环
                              不能控制循环的执行 

                5, 数组去重
                    数组坍塌: 执行删除数组单元操作,删除单元之后的单元,会前移,造成数组长度减少,这样的情况称为数组的坍塌
                    影响: 通过循环操作数组,删除单元,之后的单元前移,如果不改变循环的执行,就会有一个单元没有参与循环的执行
                          效果见 数组坍塌 ppt

                    (1), 新建数组
                        原理: 新建一个数组,将原始数组中的数据,赋值给新的数组存储
                              赋值时 使用 indexOf() 执行判断
                              如果新数组中没有 当前要写入的数据 也就是 indexOf() 的执行结果是 -1
                              再执行 赋值操作

                    (2), 数组排序比较去重
                        原理: 将数组先进行排序,排序之后,存储相同数据的单元,就会相邻排列
                              从第一个单元开始,与下一个单元 进行比较 
                              如果存储数据相同,删除下一个单元
                              发生了删除数组单元操作,执行 i-- 再次 循环这个单元

                    (3), 双层for循环比较
                        原理: 外层循环,遍历从第一个到倒数第二个单元
                              内存循环,遍历 从 当前单元的下一个单元开始 到 最后一个单元
                              如果 外层循环变量作为下标,获取的数据,与 外层循环变量作为下标,获取的数据 相同
                              删除 内存循环变量,对应索引下标的单元
                              发生了删除数组单元操作,执行 内层循环变量-- 再次 循环这个单元
                              
                    
        */

        function fun(){
            console.log(123);
        }

        // console.log( fun() );

        // 输出 fun 函数名称 中 存储的内容
        // 当前不是 在 调用函数 只有 函数名称() fun() 才是调用函数
        // fun 中 本质上 存储的是 函数的 内存地址 
        // 浏览器会 解析 内存地址 获取 内存地址中 存储的内容
        // 以 字符串形式 存储的 函数程序 内容  
        console.log( fun );

        // 这是一个赋值语句
        // 要给变量 a 赋值 100
        // 现在整个程序都没有这个变量a
        // 赋值语句,升级为 一个 声明语句 
        // 在全局作用域中 声明一个 a变量 并且赋值 100
        a = 100;

        // 正常的定义声明一个全局作用域变量b,并且赋值100
        var b = 100;


    </script>
</body>
</html>