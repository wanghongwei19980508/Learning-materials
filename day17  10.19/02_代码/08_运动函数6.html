<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        div {
            width: 400px;
            height: 400px;
            background: pink;
            position: fixed;
            top: 0px;
            left: 500px;
        }
    </style>
</head>

<body>
    <button>开始</button>
    <div></div>

    <script src="./tools.js"></script>
    <script>
        /*
            运动函数1:
                解决的问题:
                    1, 通过累加 数据的方式,将css属性值的改变,逐步完成实现
                       执行效果看似动画
                    2, 通过参数 执行动画的标签对象
                               执行的属性
                            
                    3, 运动执行完毕,执行的程序

            运动函数2:

                没有解决的问题
                    1, 初始值现在是固定数值
                        需要获取标签的原始属性的数据
                        获取的属性,是需要改变css样式的属性
                        这个属性的初始值

                    2, 最终数值是固定数值
                        作为一个参数,输入
            
            运动函数3:

                新增问题1: 如果是多属性运动,怎么办?
                    每一个运动的属性,都要匹配一个最终值,必须是键值对的形式
                        一个属性 配对一个 最终值
                    使用 对象 来 存储 运动属性和最终值

            运动函数4:
                每次累加的数值,不一定就是正数
                甚至每次累加的数值,都有可能不是固定的数值

                每次改变的数值,就设定成,一个改变的数值
                    ( 最终值 - 初始值 ) / 完成次数

                取整: 步长大于 0 向上取整
                      步长小于 0 向下取整

            运动函数5 : 如何判断到达最终位置,清楚定时器,判断运动停止了
                定义一个对象,对象的属性可以是字符串,可以同时存储运动属性的名称
                如果是数组:索引下标只能是 数字

                每次生成一个定时器,就向 对象 中存储一个定时
                对象的属性是 运动属性的名称 也就是 当前运动的是 left 对象的属性就是left
                对象的属性值是 定时器的序号 

            运动函数6 : 兼容透明度:
                如果运动属性是 透明度 , 获取初始值,放大一个固定倍数,一般是 100倍
                最终数值,步长,等都要按照倍数执行
                赋值时,要去掉px单位

        */

        var oDiv = document.querySelector('div');
        var oBtn = document.querySelector('button');

        // 点击button按钮,执行 运动函数
        oBtn.addEventListener('click', () => {
            move(oDiv, {opacity:0});

        })


        function move(element, typeObj , fun) {
            // 定义一个对象,存储定时器
            var obj = {};

            // type就是运动的属性,也就是 left top width...
            for(let type in typeObj){
                // setInterval() 执行结果,是 定时器的编号
                // 对象[type] 就是 将 type 运动属性left等,作为对象的属性
                // 将 setInterval() 的执行结果,也就是 1,2,3... 等编号,作为对象的属性值
                obj[type] = setInterval(() => {
                    // 1, 获取初始值 
                    // 需要兼容 透明度 , 如果是透明度,获取初始值,放大100倍
                    //                   不是透明度,取整,不要px单位
                    let startVal = type === 'opacity' ?  myGetStyle(element, type)*100 : parseInt(myGetStyle(element, type));
                    
                    // 兼容透明度,最终值乘以100;
                    let endVal = type === 'opacity' ? typeObj[type]*100 : typeObj[type] ;
            
                    // 2, 累加数值 / 步长   应该是  ( 最终值 - 初始值 ) / 设定的次数
                    // 步长值 ,最终几次执行,有可能,是小数,累加的结果是不足1的
                    // css样式中,对于不足1的小数像素,执行,有可能是向下取整,有可能是向上取整
                    // 需要要先对,speed,步长值取整 0.5 向上取整是 1
                    //                          -0.5 向下取整是 -1
                    // speed 大于 0 , 向上取整, 否则 就向下取整

                    // 兼容透明度: 如果是 透明度 , 最终数值也要乘以100 再减去初始值
                    //              不是 透明度 , 最终值直接 减去 初始值
                    let speed = ( endVal - startVal  ) / 50 ;

                    // 对 speed 取整:
                    // speed 如果 大于 0 ,就将 speed 向上取整,赋值给 speed 本身
                    // speed 如果 小于 0 ,就将 speed 向下取整,赋值给 speed 本身
                    speed = speed > 0 ? Math.ceil(speed) :  Math.floor(speed);

                    // 初始值 累加 步长 (步长,有可能是正数,也有可能是负数)
                    startVal += speed;

                    // 3, 将累加之后的数值,赋值给标签css样式的属性值
                    // 兼容透明度 : 如果是 透明度 没有 px单位 数值需要除以100 
                    //              不是 透明度  添加 px 单位
                    element.style[type] = type === 'opacity' ? startVal/100 : startVal + 'px';

                    // 4, 判断,如果到了最终目标位置,停止定时器
                    // startVal 是 当前的属性值
                    // typeObj[type] 是 最终属性值 top:500  left:1000

                    // 如果是 透明度 最终值 乘以 100
                    //      
                    if(startVal === endVal ){
                        // 清除定时器
                        // 应该是 clearInterval(定时器编号)
                        // 当前编号存储在对象的属性中
                        // 要想获取 应该是  obj[运动属性]
                        clearInterval(obj[type]);
                        // 定出掉的定时器,就从对象中删除
                        delete(obj[type]);
                        // 如果对象是一个空对象,证明所有的定时器都清除了
                        // 证明运动真的停止了
                        // 使用: Object.keys(对象) JavaScript提供的方法
                        // 获取对象中,所有的键名,组成一个数组
                        // 当对象是一个空对象,数组就是一个空数组,length就是0
                        const objKeyArr = Object.keys(obj);
                        if(objKeyArr.length === 0){
                            // 如果数组的长度是 0 ,证明数组是一个空数组,对象是一个空对象
                            fun();
                        } 
                    }
                }, 30)
            
            }
        }

        /*
            总结:
            
            解决的问题
                1, 初始值的问题:
                    每次执行定时器,通过定义的函数,获取标签,要执行运动的css样式的属性值

                2, 最终值的问题:
                    使用一个参数来解决

            新的问题:
                如果是 两个属性 要同时执行运动效果,怎么办?

                解决方案:
                    第二个参数,使用对象,以键值对的形式,输入,需要运动的属性和最终运动位置的最终数值

                    在move函数中,通过循环遍历,来获取每一个单元,运动的属性和最终值

                    每次执行一个 定时器 , 完成运动效果

                    有几个运动属性,就会生成几个定时器
                    
                    定义循环变量,必须使用 let 关键词声明

            运动函数3,新的问题:
                    每次累加改变的数值,都是一个正数,只能变大,不能变小,只能右移下移,不能左移上移

                    解决方案:
                        每次使用 (最终值 - 初始值) / 设定的次数 计算步长
                        这个 步长值 是一个 改变的值 
                        设定的次数 不是 定时器 最终执行的次数
                            只是每次 当前位置 到 最终位置 的距离 分成几次执行完毕
                            设定的次数,等于程序的执行,只有一个影响,影响运动速度,数值越大,运动的越慢

                        步长值,每次都不同,一定有是小数的时候,
                        需要对步长值,取整,
                            步长值 大于 0  向上取整 确保至少移动  1px 的 位移
                            步长值 下于 0  向下取整 确保至少移动 -1px 的 位移

            新问题 : 怎么停?
                现在有可能是多属性运动,而且,初始数值最终数值不同,运动执行的次数也就不同  
                怎么让运动停止,怎么知道运动真的停了 

                解决方案:
                    在函数中,创建一个对象,用于存储所有生成的定时器
                    如果是多属性运动,每一个属性都会生成一个定时器
                    将定时器存储在对象中,运动的属性,就是对象的属性,定时器的序号,就是对象的数值
                        obj[type] = setInterval() 
                    
                    运动到最终位置,就清除定时器
                        从对象获取当前运动属性,对应的定时器的序号
                        清除定时器之后,从对象中删除存储当前属性的单元

                    通过 object.keys(对象) 获取对象中,所有单元的属性,组成数组
                    
                    数组如果长度是0,对象就是空对象,所有运动就都停止了

            运动函数5,新的问题
                    如果要改变的属性是 透明度:
                        1, 透明度的属性值 是 0-1的小数,如果按照现在,取整的方法,一次就完成了数值的改变
                            0 变成 1 , (1-0)/5    0.2   向上取整 就是 1 一次就从 0 变成  1
                        2, 透明度没有px单位
                    
                    解决方案:
                        如果 循环是 属性 是 透明度 type 是 opacity 
                            获取 的 初始值 和 参数中 输入的最终值 都乘以 100
                            别的操作都相同
                            赋值标签style属性值时, 透明度 数值 除以100 ,不要加px
                                                其他属性 数值 拼接 px 单位
            
            最后的问题:
                所有的运动都停止了,需要执行对应的函数程序
                move()函数设定第三个参数,当 存储定时器对象为空对象时,调用执行第三个参数,输入的函数
                输入的函数可以是匿名函数,也可以是定义好的函数名称

        */

    </script>
</body>

</html>