<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        /*
            ES5的继承语法:
                1,原型继承
                    在 子类构造函数的 prototype 中 添加 父类构造函数生成实例化对象
                    通过 原型链 的作用,让 子类构造函数 可以 访问 父类构造函数 prototype 中 定义的函数方法

                    原型链: 所谓的原型链,本质上就是数据链
                           作用就是让相互关联的 对象 和 函数 可以 访问彼此存储的数据
                           通过 __proto__ 将 对象和函数 相互串链起来

                           prototype 是 函数天生就有的属性,是一个公共的存储空间
                                        本身也是 对象类型 也有 __proto__

                           __proto__ 是 对象天生就有的属性,指向 函数的 prototype

                2,借用构造函数继承
                    在 子类构造函数中 调用执行 父类构造函数 同时 改变父类构造函数,this指向
                    继承的是 父类构造函数中 的属性和属性值

                3,组合继承
                    两种方法一起使用,同时可以调用父类的函数方法和继承属性属性值
        
                function Father(name,age){
                    this.name = name;
                    this.age = age;
                }
                Father.prototype.fun1 = ()=>console.log('我是父类构造函数定义的程序');

                function Son(sex){
                    Father.call(this , '张三' , 18);
                    this.sex = sex;
                }

                Son.prototype = new Father('李四',20);

                Son.prototype.f1 = ()=>console.log('我是子类构造函数定义的程序');

            闭包:
                是 函数 的一种高级应用方法
                目的:为了可以调用函数中,定义的局部数据
                作用:为了将全局作用域变量,防止全局污染,我们会将全局作用域变量,写成函数中的局部作用域变量
                     之后,再通过闭包的形式,来访问调用数据
                函数的执行过程:
                    封装:
                        在内存中开辟一个存储空间,定义内存地址,准备存储函数程序
                        将函数程序以字符串形式,存储在 存储空间中
                        将内存地址,存储在 函数名称 或者 变量中

                    调用:
                        通过 函数名称 或者 变量 中 存储的内存地址,找到存储空间,调用其中存储的内容
                        形参赋值实参
                        预解析函数程序
                        执行函数程序
                            在函数的存储空间中,再开辟一个执行空间
                            在执行空间中,存储函数,局部作用域变量和数据
                            函数执行结束之后,执行空间就会被销毁
                            其中存储的数据也就被销毁

                生成一个不会被销毁的执行空间
                    函数的返回值 是一个 引用数据类型 
                    并且在函数之外,有变量来存储这个引用数据类型

                    返回引用数据类型,外部变量存储的是 引用数据类型的内存地址
                    如果存储空间被销毁,引用数据类型就会被销毁
                    内存地址就没有意义了
                    因此函数会保留执行空间不会销毁

                闭包:
                    1, 函数A 返回值 是 函数B
                    2, 在函数A的外部,有程序存储使用返回值函数B
                    3, 在函数B中 调用使用 函数A 其中的数据数值

            立即执行函数 / 自执行函数
                在函数封装时,就会立即执行函数
                立即执行函数,只会被执行一次
                (函数)()
                !函数()
                ~函数()

            设计模式
                面向对象编程的一种高级应用
                所有的设计模式都是为了解决固定的问题,形成的一种编程方式

                工厂模式
                    相同属性,不同属性值的对象的创建

                    function fun(){
                        const obj = {};
                        obj.属性 = 属性值;
                        obj.属性 = 属性值;
                        ....
                        obj.函数 = function(){}
                        obj.函数 = function(){}
                        ...
                        return obj
                    }


                组合模式
                    项目中,有多个实例化对象,每一个实例化对象,都有init()入口函数要调用
                    将所有的实例化对象都存储在一个数组中,循环遍历数组,一次性调用所有的入口函数


                    class Group{
                        constructor(){
                            this.arr = [];
                        }

                        add(...object){
                            object.forEach( v=> this.arr.push(v) );
                        }

                        extends(){
                            this.arr.forEach( v=> v.init() );
                        }
                    }


                单例模式:
                    实际项目,同一个构造函数,生成的实例化对象,只是属性值不同,属性和方法都完全相同
                    重复的定义实例化对象,就造成了冗余程序

                    1, 不再将属性属性值,定义在,实例化对象上
                       而是在调用函数方法时,输入实参

                    2, 定义变量,如果是原始值,调用构造函数,将实例化对象存储在变中,返回值是变量
                               如果不是原始值,不再调用构造函数,直接返回变量

                    3, 为了保证变量,不会被全局污染,写在函数中,通过闭包来调用访问


                    const tools = (function(){
                        let res = '初始值';

                        class Fun{
                            constructor(){}

                            f( 形参 ){}
                        };

                        return function(){
                            if(res === '初始值'){
                                res = new Fun();
                                return res;
                            }else{
                                return res;
                            }
                        }
                    })()
                    
        
        */








    </script>
</body>
</html>