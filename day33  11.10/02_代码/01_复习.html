<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script src="./jquery.min.js"></script>
    <script>
        /*
            一,jQuery
                1, 钩子函数
                    作用: 与异步程序挂钩,在异步程序执行到不同的状态时,执行不同的回调函数
                         原因: 异步程序,执行过程,执行时间等,不可控的

                    与 jQuery 封装的 ajax 请求 挂钩 

                        1, 在所有的 jQuery ajax 请求开始之前执行的 回调函数
                            $(window).ajaxStart()

                        2, 在每一个 jQuery ajax 请求发送之前执行的 回调函数
                            $(window).ajaxSend()

                        3, 在每一个 jQuery ajax 请求成功时执行的 回调函数
                            $(window).ajaxSuccess()

                        4, 在每一个 jQuery ajax 请求失败时执行的 回调函数
                            $(window).ajaxError()

                        5, 在每一个 jQuery ajax 请求结束时执行的 回调函数
                            $(window).ajaxComplete()

                        6, 在所有的 jQuery ajax 请求结束之后执行的 回调函数
                            $(window).ajaxStop()

                2, jQuery的特殊事件
                    (1), 只会执行一次的事件
                        $().one('事件类型' , 事件处理函数)

                    (2), 事件的发布  默认会执行已经绑定的所有事件处理函数
                        $().事件类型(事件处理函数)

                        $().trigger(事件类型)

                    (3), 事件的删除
                        $().off()               删除所有类型所有事件
                        $().off(类型)           删除指定类型的所有事件
                        $().off(类型,函数名称)   删除指定类型的指定事件

                    (4), hover事件
                        $().hover(事件处理函数1 , 事件处理函数2)
                            事件处理函数1 : 鼠标移入
                            事件处理函数2 : 鼠标移出

                    (5), ready事件
                        与 window.onload 类似

                        window.onload,是 当所有标签,所有标签内容都加载完毕之后,才会执行
                        $(window).ready ,只要标签加载完毕,就可以执行
                        以 img 标签 为例子 
                            window.onload 是 图片 内容加载显示完毕之后,才会执行
                            $(window).ready 是 图片标签 加载完毕,即时图片没有显示,也会执行

                3, 多库并存
                    本质: 控制 jQuery的 标识符 $ 和 jQuery 与 其他 函数的库的标识符冲突
                         jQuery 会 放弃 $ 或者 jQuery 标识符的控制权

                         $.noConflict()                  让出 $ 
                         $.noConflict(true)              让出 $ 和 jQuery
                         let 变量 = $.noConflict(true)   使用变量作为标识符,控制jQuery
                         
                4, 深浅拷贝
                    (1) 只有 引用类型 才会考虑深浅拷贝的问题

                    (2) 浅拷贝
                        拷贝 赋值 的是 引用类型 的 内存地址
                        效果: 两个变量,通过任意一个变量,操作引用类型,另一个变量,也会跟着一起改变
                        原因: 两个变量,存储相同的 内存地址,也就是两个变量,同时操作一个内存地址

                    (3) 深拷贝
                        拷贝 赋值 的是 引用类型 每一个单元 存储的具体的数值数据
                        效果: 两个变量,通过任意一个变量,操作引用类型,另一个变量,不受影响
                        原因: 两个变量,存储不相同的 内存地址,也就是两个变量,操作的是两个内存地址

                    (4) 原生JavaScript程序
                        一般是写一个 递归函数 来完成 深拷贝
                        如果 数据类型 是 对象,数组,函数, 就 循环遍历,获取其中的每一个数据

                    (5) jQuery实现深拷贝
                        注意: jQuery的深浅拷贝,如果是 基本数据类型, 都是深拷贝
                              引用数据类型,才会考虑深浅拷贝
                              jQuery默认执行的是饮食迭代

                        语法1: 浅拷贝 $.extend(变量1 , 变量2 , 变量3.... )  
                            将 变量2 和 变量3等等 中 存储的数据 都 拷贝 到 变量1中

                        语法2: 深拷贝 $.extend(true , 变量1 , 变量2 , 变量3.... )  
                            将 变量2 和 变量3等等 中 存储的数据 都 拷贝 到 变量1中

                5, 向jQuery新增方法
                    $.extend() 是 添加自定义方法的关键词
                        语法1: 直接添加给jQuery的,通过 $.函数名称来调用
                        $.extend({
                                自定义函数名称1: ()=>{程序},
                                自定义函数名称2: ()=>{程序},
                        }) 



                        语法2: 是 直接添加给标签对象的 , 通过 $.().函数名称 来调用
                            一般对于标签对象,都要执行链式编程,必须要有 return 和 返回值 
                            一般返回值,就是你操作的标签对象

                            编辑的对象,和返回值 都是 this 
                            这个 this 是一个 jQuery标签对象

                        $.fn.extend({
                            自定义函数名称1: ()=>{ return 返回值 },
                            自定义函数名称2: ()=>{ return 返回值 },
                        })
                    
                    总结: $.extend() 新增的方法是 给 jQuery函数库的
                            通过 $.方法 来调用
                          $.fn.extend()  新增的方法是 给 jQuery标签对象的
                            通过 $.().方法 来调用
                            操作 和 返回的 一般都是 this

                6, jQuery的节点操作
                    (1) 新增节点
                        const 变量 = $('<标签 属性...>内容</标签>')

                    (2) 节点写入
                        父级写入子级标签
                            父级末位写入
                                $(父级).append(写入的子级)
                                $(写入的子级).appendTo(父级)

                            父级起始写入
                                $(父级).prepend(写入的子级)
                                $(写入的子级).prependTo(父级)


                        平级兄弟标签写入
                            已有标签后写入
                                $(已有标签).after(写入的标签)
                                $(写入的标签).insertAfter(已有标签)

                            已有标签前写入
                                $(已有标签).before(写入的标签)
                                $(写入的标签).insertBefore(已有标签)

                    (3) 删除
                        $().empty()    清除内容
                        $().remove()   删除整个标签

                    (4) 克隆
                        $().clone()              只克隆标签和标签内容
                        $().clone(true)          克隆标签和标签内容,以及标签和子级标签绑定的所有事件
                        $().clone(true,false)    克隆标签和标签内容,以及只克隆当前标签的事件,不克隆子级标签事件
            
            
            
            二,ES6语法
                1 , Map数据类型
                    类似于 对象的数据 类型 以 键值对形式存储数据

                    声明必须通过构造函数声明
                    声明时,以二维数组的形式,定义赋值数据
                    每一个数组的单元,都是map类型的一个单元
                    二维数组,第一个单元,是键名 
                    二维数组,第二个单元,是键值

                        const map = new Map( [ ['键名' , 键值] , ['键名' , 键值] , ['键名' , 键值] , ['键名' , 键值] ] ) 


                    新增单元   
                        map类型.set(参数1,参数2)
                            参数1:新增单元的键名
                            参数2:新增单元的键值

                    调用使用  
                        map类型.get(键名)
                            通过键名来调用键值
                            不用管 0,1,2...的索引,直接拿键名调用数据

                    删除:  删除一个
                        map类型.delete('键名')
                            通过键名来删除单元

                    清除:  删除所有
                        map类型.clear()

                    循环:  与普通的forEach() 循环 完全一样
                        map类型.forEach((键值,键名)=>{})

                    判断:  map中是否有这个键名
                        map类型.has('键名')  结果是布尔类型


                2 , Set数据类型
                    类似于 数组的数据类型
                    定义时,以一维数组来定义存储的数据
                    set类型不会存储重复的数据

                    const set = new Set([数据....])

                    调用使用:
                    set类型中的数据,不能通过索引下标等直接调用
                    方法1: 通过 展开运算符,将 set类型展开,然后通过索引下标来获取
                        [...set][0]
                        [...set] 通过 展开运算符,将set类型中的每一个单元,展开,赋值给数组存储
                        之后在 通过 数组的索引下标,来获取数据

                    新增:
                        set类型.add(数据);

                    删除
                        set类型.delete('删除');

                    清除
                        set类型.clear();

                    循环遍历
                        两个形参,存储的都是数值数据,没有存储索引下标的形参
                        set类型.forEach( (v,v)=>{} )

                    判断
                        set类型.has(数值)  判断结果是布尔类型
                    
                3, 数组去重的方法
                    (1) indexOf()
                    (2) 先排序,再循环遍历
                    (3) 双重for循环
                    (4) 对象不会存储重复的键名
                    (5) set类型不会存储重复的数据
        
            三, 面向对象的继承语法
                1 , ES6的继承语法

                    class 父类{
                        constructor(){
                            属性
                        }
                        方法(){}
                    }

                    class 子类 extends 父类{
                        constructor(){
                            super(父类继承的属性)
                            自己的属性
                        }

                        父类方法自动可以调用

                        定义自己的方法
                    }
        
        */


        const obj1 = {name:'张三',age:18,arr1:[1,2,3,4,5]};
        const obj3 = {sex:'男',addr:'北京', arr2:[6,7,8,9,10]};

        const obj2 = {};

        // 虽然执行的是浅拷贝
        // 但是 jQuery执行的是 隐式迭代, 会默认循环遍历 obj1 和 obj3 对象
        // 如果是基本数据类型,会做拷贝赋值 数据数值
        // 如果是引用数据类型,会做拷贝赋值 内存地址 --- 浅拷贝
        $.extend( obj2 , obj1 , obj3 );

        obj1.name = '李四';
        obj3.sex = '不知道';

        obj1.arr1[0] = '一';
        obj3.arr2[0] = '六';

        console.log(obj2);




    </script>
</body>
</html>