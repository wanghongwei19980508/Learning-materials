<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        /*
            单例模式的核心原理:
                1, 解决的问题:
                    同一个构造函数,生成的实例化对象,只是具体的数据属性值不同
                    函数方法,属性,都是完全相同的
                    等于是在重复定义,只是数据不同的 实例化对象

                    通过单例模式,同一个构造函数,只会创建相同的实例化对象
                    在调用函数程序时,再输入不同的实参

                2, 解决方式:
                    核心思想:
                        定义一个变量,存储原始数据
                        通过判断: 如果是原始数据 --- 调用 构造函数,生成实例化对象
                                                   存储在变量中
                                                   return 返回这个变量
                                  如果不是原始数据 --- 直接 return 返回这个变量

                        效果:  1, 第一次调用,生成一个实例化对象,内存地址,存储在变量中
                                  返回这个变量,也就是返回内存地址

                               2, 之后所有的调用
                                  不会再次调用构造函数,生成新的冗余的实例化对象
                                  会直接返回之前创建的 实例化对象 的内存地址
                                  不管调用多少次,返回的都是同一个内存地址

                3, 实际应用:
                    为了保护变量的数据安全,不会被全局污染
                    将变量定义在一个函数中,通过闭包的方式,来调用执行变量数据

                    通过立即执行函数,直接存储返回值 函数

                    const tools = (
                        function(){
                            let res = '原始值';
                            class Fun{};
                            return function(){
                                if(res === '原始值';){
                                    res = new Fun();
                                    return res;
                                }else{
                                    return res;
                                }
                            }
                        }
                    )() 
                        
                    这里的 class Fun{} 可以根据实际项目自行定义
        
        
        
        
        
        */
    </script>
</body>
</html>