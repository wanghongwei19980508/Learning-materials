<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        /*
            一 , 排序算法
                1, 冒泡排序
                    核心:
                        从第一个单元开始,当前单元和下一个单元进行比较
                        如果第一个单元数值较大,交换两个单元,存储的数据

                        每一次内层循环,会将一个较大值存储在,数组的末位

                        n个单元,循环 n-1 次

                        之前循环排序出的较大值 不参与之后的循环

                    优化:
                        1, 一次内层循环, 从当前单元 到 倒数第二个单元
                           最后一个单元,没有下一个单元进行比较

                        2, 内层循环,之前循环比较出的较大值,不参与下一次循环

                        3, 外层循环 n 个单元 循环 n-1 次
                           最后一个就剩下一个单元,没有其他单元与他比较

                2, 选择排序
                    核心
                        选择最小值的索引下标
                        判断,如果不是起始位置的索引下标
                        就交换最小值位置和起始位置存储的数据

                        每次内层循环会将最小值存储在数组的起始位置 

                        n个单元,循环 n-1 次

                        之前循环排序出的较大值 不参与之后的循环

                    优化
                        1 , 内层循环从 当前单元的下一个单元开始循环
                                                
                        2, 内层循环,之前循环比较出的较大值,不参与下一次循环

                        3, 外层循环 n 个单元 循环 n-1 次
                           最后一个就剩下一个单元,没有其他单元与他比较
        
        */


        var arr = [5,4,3,2,1];

        // 冒泡排序
        // for(var i = 0 ; i <= arr.length-1 -1 ; i++){
        //     for(var j = 0 ; j <= arr.length-1 -1 -i ; j++){
        //         if(arr[j] > arr[j+1]){
        //             var tmp = arr[j];
        //             arr[j] = arr[j+1];
        //             arr[j+1] = tmp;
        //             bool = false;
        //         }
        //     }
        // }


        // 选择排序
        // for(var i = 0 ; i <= arr.length-1-1 ; i++){
        //     var index = i;

        //     for(var j = i+1 ; j <= arr.length-1 ; j++){

        //         if( arr[index] > arr[j] ){
        //             index = j;
        //         }
        //     }

        //     if( i !== index ){
        //         var tmp = arr[i];
        //         arr[i] = arr[index];
        //         arr[index] = tmp;
        //     }
        // }

        // 定时器,延时器
        //     setInterval( 匿名函数 / 函数名称 , 时间间隔 )
        //     setTimeout( 匿名函数 / 函数名称 , 时间间隔 )
        // 定时器: 按照设定的时间间隔,重复执行设定的程序,多次执行程序
        // 延时器: 按照设定的时间间隔,延迟执行设定的程序,只会执行一次
        // 清除 : clearInterval()  clearTimeout()
        //        ()中定义的是 定时器延时器的 序号 , 可以是变量存储的,也可以直接写数值
        //        可以混用的

        // 同步异步执行
        //    大部分程序,都是同步程序,特殊的程序才是异步程序
        //    定时器,延时器,事件绑定,ajax请求,都是异步程序
        //    先执行所有的同步程序,异步程序存储在异步池中
        //    当所有的同步程序执行结束,同时开始执行异步程序
        //    时间间隔短的异步程序会先执行
        //    时间间隔相同的异步程序,按照顺序执行
        

        // 函数中的this指向
        // 基本函数中的this指向 --- 调用函数时,点, 之前的内容,就是this指向
        //    1, 对象中的函数 , this 指向 对象本身
        //    2, 声明式 赋值式 函数 , 存储在 顶级对象 window 中 , this指向  window
        //    3, 特殊函数: 定时器,延时器,forEach --- window

        // 数组的4个方法
        // arr.map( function(数据,索引,原始数组){ return 数据的操作 } )   映射
        // arr.filter( function(数据,索引,原始数组){ return 数据的比较判断 } )   筛选
        // arr.some( function(数据,索引,原始数组){ return 数据的比较判断 } )   有一个符合,返回值就是true
        // arr.every( function(数据,索引,原始数组){ return 数据的比较判断 } )  必须都符合,返回值才是true

    </script>
</body>
</html>