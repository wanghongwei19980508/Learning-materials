<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        /*
            一 没有模块化
                按照 程序执行顺序,通过 script标签 加载外部js文件
                问题:
                    1,标签顺序不能改变,必须按照顺序执行
                    2,程序依赖不明确 不知道谁在使用谁  谁又在被谁使用
                    3,全局变量污染


            二 IIFE 标准  是 程序员自己定义的一套标准
                Immediately Invoked Function Expression   自执行函数标准方法
                    通过 定义一个 自执行函数/立即执行函数 (function(){})()
                    将全局变量定义为局部作用于变量,通过 return 来 返回 定义的变量数据
                    在函数之外 可以调用使用 这些数据

                    解决了     全局变量污染的问题
                    没有解决   执行顺序和依赖不清晰的问题

            三 AMD / CMD
                最早在 JavaScript社区(论坛) 发起 定义的 前端 模块化开发标准

                AMD的开发模式
                    Asynchronous Module Definition

                    2011年最早在社区出现的,程序员自己定义的 前端 模块化开发方式

                    因为是非官方的开发模式,就必须要先加载一个外部js文件
                        require.js 其中封装了 AMD 开发模式的程序

                    执行步骤
                        1,先导入一个 外部 require.js 文件
                        2,定义 独立模块 --- 只是自己的程序,没有其他其他模块
                            在代码中使用 
                                define() 方法 来定义 模块程序
                                         就是一个程序,没有依赖其他内容,有导出

                                define(function{定义的程序 return 暴露的数据})

                        3,定义 依赖模块 --- 要依赖其他程序,才能执行
                            定义一个模块,但是我要依赖其他模块
                                define() 方法来定义模块程序
                                         同时通过参数,来加载依赖的模块文件

                                define(['依赖文件1路径','依赖文件2路径','依赖文件3路径'] , function(){定义的程序 return 暴露的数据})

                    解决问题: 1,解决了 全局变量污染
                             2,解决了 模块文件依赖

                    产生问题: 1,文件顺序 
                             2,前置依赖 --- 必须要记住
                                如果执行一个文件时,需要依赖多个文件,这些文件会先加载
                                会先将所有的依赖文件都加载完,再执行 function(){} 中定义的程序
                                文件执行时间会过长
                                但是一旦加载完成,之后的执行会很方便

                    AMD 总结 :
                        通过 define() 来记载 其他模块 同时通过 return 来暴露导出 程序数据
                        解决了 依赖不清晰的问题 和 全局变量污染
                        但是 有 前置依赖的问题
                            首个程序要在 所有加载文件都执行完毕之后,才会执行
                            但是 加载依赖文件结束之后,执行会很顺畅


                CMD 的 开发模式 
                    Common Module Definition
                    由 阿里 玉伯 (王保平) 开发的 前端模块化开发模式
                    也要依赖一个外部文件 sea.js 
                    也是为了解决 前端模块化问题 参考的就是 后端的 nodejs CommonJS 模式

                    执行步骤:
                        1, 加载 外部 sea.js 文件
                        
                        2, 定义 独立模块
                            define(function(参数1,参数2,参数3){})
                                参数1: require 也就是你要依赖的内容
                                参数2: exports 也就是你要导出的内容
                                参数3: module  是 exports 的一个别名

                            也是定义了一个 module 对象 module.exports 来定义导出内容
                            导出的语法和 Commonjs 完全相同

                        3, 定义 依赖模块
        
                            define( function( require , exports , module ){
                                使用 var modA = require('导入模块地址')
                            } )

                        4, 定义 整合模块
                            使用 seajs.use()  将 所有模块整合到一起

                            使用 seajs.use( ['依赖文件1路径' ，'依赖文件2路径' ，'依赖文件3路径' ] ， function(导入模块1,导入模块2,导入模块3){
                                程序执行时 调用 模块中的 导出的程序
                            } )

                    解决问题: 1, 全局变量污染问题,解决了前置依赖问题
                                 在 程序需要时 才会通过 参数 导入使用 外部模块

                    问题: 1, 后置依赖
                            执行模块时 先不加载 所需要的模块
                            在程序执行需要时,才会去加载 模块 
                            一开始执行程序 会很快 但是 程序执行不够流畅

                    CMD 总结: 通过 define() 导入模块,执行程序,导出数据
                              最后通过 saejs.use() 一次性整合所有的 模块 

                              后置加载:
                                整合所有的模块,在需要的时候,再来加载调用模块
                                程序一开始执行会很快,之后执行不够流畅

                    之前 前端 开发 AMD 和 CMD 两种模块化开发要同时进行
                    有些效果 使用 AMD , 类似于 购物车 列表页
                    有些效果 使用 CMD , 类似于 秒杀页面
                    


            四 ES6规范中的模块化
                在 2015 年 发布的 ES6中 就内置了 模块化开发模板
                但是 当时 浏览器厂商不支持

                直到 2016年 有了 VUE框架 , 有一个 脚手架 功能 
                会一次性的生成所有的 页面需要的框架 你只要写入内容就可以了
                vue的脚手架中 就 默认加载了 ES6 模块化开发语法

                各大浏览器厂商才开始 支持 ES6 模块化开发

                我们现在前端的模块化 都是使用 ES6 模块化语法
                都是使用VUE等框架来完成

                ES6的模块化语法
                    1, 是官方的模块化语法 不需要加载独立的文件
                       只要使用关键词就可以了

                       但是必须要在 服务器上运行才可以
                       本地直接打开运行,程序会报错

                    2, 基本步骤
                        (1) 定义一个script标签,标签的 type属性 module  
                            表示是一个模块化的js程序

                        (2) 每一个有 type="module"的js文件都是一个独立的模块
                            exports default 来定义 导出的内容 
                                            可以是 一个 对象也可以是 一个变量

                                exports default {}
                                exports var int = 100;

                            
                            import { 接收的变量 } form '外部js文件' 来接收导入文件的数据

                            之前ES6 只能做 前置依赖 

                        2020年 新出了 ES2020 新增了 新的 模块化语法 
                            import {你要加载文件.then(function(){res})}

                            有了这个语法, ES2020 可以做 后置依赖

                            也就是在一个文件程序中,可以同时有 前置依赖 和 后置依赖
                            提高程序的执行效率

        
        
        
        
        */
    </script>
</body>
</html>